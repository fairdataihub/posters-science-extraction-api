# Workflow to deploy the application to a GPU server
name: Deploy to GPU server

# Concurrency control: ensures only one deployment runs at a time
# If a new deployment starts, it will cancel any in-progress deployment
concurrency:
  group: production
  cancel-in-progress: true

# Trigger conditions: runs on push to main branch or manual trigger
on:
  push:
    branches: [main]
  workflow_dispatch: # Allows manual triggering from GitHub Actions UI

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      # Checkout the repository code to the GitHub Actions runner
      - name: Checkout
        uses: actions/checkout@v4

      # Install rsync utility needed for efficient file synchronization
      - name: Install rsync
        run: sudo apt-get update && sudo apt-get install -y rsync

      # Configure SSH access to the deployment server
      - name: Setup SSH
        run: |
          # Create SSH directory if it doesn't exist
          mkdir -p ~/.ssh
          # Write the private key from GitHub secrets to SSH key file
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_ed25519
          # Set proper permissions for the private key (read/write for owner only)
          chmod 600 ~/.ssh/id_ed25519
          # Add server's host key to known_hosts to avoid host verification prompts
          ssh-keyscan -H ${{ secrets.SSH_HOST }} >> ~/.ssh/known_hosts

      # Synchronize code from GitHub Actions runner to the deployment server
      - name: Sync code to server
        run: |
          # Extract repository name from GITHUB_REPOSITORY (e.g., "owner/repo" -> "repo")
          REPO_NAME="${GITHUB_REPOSITORY#*/}"
          # Set destination path on the server
          DEST="~/deploy/$REPO_NAME"

          # rsync flags:
          # -a: archive mode (preserves permissions, timestamps, etc.)
          # -z: compress during transfer
          # --delete: delete files on destination that don't exist in source
          # --exclude: skip these directories (large files that shouldn't be synced)
          rsync -az --delete \
            --exclude ".git/" \
            --exclude "data/" \
            --exclude "models/" \
            --exclude "checkpoints/" \
            --exclude "node_modules/" \
            -e "ssh -i ~/.ssh/id_ed25519" \
            ./ ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }}:"$DEST/"

      # Deploy the application using Docker Compose on the server
      - name: Compose up on server
        run: |
          # Re-extract repository name and destination path
          REPO_NAME="${GITHUB_REPOSITORY#*/}"
          DEST="~/deploy/$REPO_NAME"

          # SSH into the server and execute deployment commands
          ssh -i ~/.ssh/id_ed25519 ${{ secrets.SSH_USER }}@${{ secrets.SSH_HOST }} << EOF
          # Exit on error, undefined variables, and pipe failures
          set -euo pipefail
          # Navigate to the deployment directory
          cd $DEST

          # Verify Docker and Docker Compose are available
          docker version
          docker compose version

          # Deploy using production docker-compose file:
          # -f: specify compose file
          # -d: run in detached mode (background)
          # --build: rebuild images before starting
          # --remove-orphans: remove containers for services not in compose file
          docker compose -f docker-compose-prod.yml up -d --build --remove-orphans
          # Optional: clean up unused Docker images (currently commented out)
          # docker system prune -f --volumes
          EOF
